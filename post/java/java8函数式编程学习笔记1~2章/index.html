<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.20" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Java8函数式编程笔记1~2 &middot; penggy Blog</title>

  
  <link rel="stylesheet" href="https://kedadiannao220.github.io/css/print.css" media="print">
  <link rel="stylesheet" href="https://kedadiannao220.github.io/css/poole.css">
  <link rel="stylesheet" href="https://kedadiannao220.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://kedadiannao220.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="penggy Blog" />
</head>

  <body class=" ">
  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://kedadiannao220.github.io/"><h1>penggy Blog</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://kedadiannao220.github.io/">Home</a> </li>
      <li><a href="/post/"> 首页 </a></li><li><a href="/about/"> 关于 </a></li>
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>Java8函数式编程笔记1~2</h1>
  <span class="post-date">Tue, Oct 10, 2017</span>
  

<h2 id="前言">前言</h2>

<h3 id="为什么要阅读本书">为什么要阅读本书</h3>

<ul>
<li>如何编写简单、干净、易读的代码，尤其是对于集合的操作</li>
<li>如何简单地使用并行计算提高性能</li>
<li>如何准确地为问题建模</li>
<li>如果写出更简单的并发代码</li>
<li>如何测试和调试Lambda表达式</li>
</ul>

<h2 id="第1章-简介">第1章 简介</h2>

<h3 id="什么是函数式编程">?什么是函数式编程</h3>

<ul>
<li>核心是：在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值</li>
</ul>

<h2 id="第2章-lambda表达式">第2章 Lambda表达式</h2>

<h3 id="第一个lambda表达式">第一个Lambda表达式</h3>

<pre><code class="language-java">        new Button().addActionListener(e -&gt; {
            System.out.println(&quot;hello world&quot;);
        });
</code></pre>

<h3 id="重要函数接口">重要函数接口</h3>

<pre><code class="language-java"> public static void functionInterface() {
        /**
         * Predicate&lt;T&gt; 入参T,返回boolean
         */
        Predicate&lt;Integer&gt; persi = x -&gt; x &gt; 6;
        System.out.println(persi.test(10));

        /**
         * BinaryOperator&lt;T&gt; 入参T,T，返回T
         */
        BinaryOperator&lt;Integer&gt; binaryOperator = (x, y) -&gt; x + y;
        System.out.println(binaryOperator.apply(10, 2));

        /**
         * Consumer&lt;T&gt; 入参T，无返回void
         */
        Consumer&lt;Integer&gt; consumer = (x) -&gt; System.out.println(x);
        consumer.accept(10);

        /**
         * Function&lt;T,R&gt; 入参T，返回R 
         */
        Function&lt;Integer, String&gt; function = x -&gt; x + &quot;10&quot;;
        System.out.println(function.apply(10));

        /**
         * UnaryOperator&lt;T&gt; 入参T 返回T
         */
        UnaryOperator&lt;Integer&gt; unaryOperator = (x) -&gt; x + 10;
        System.out.println(unaryOperator.apply(10));

        /**
         * Supplier&lt;T&gt; 入参None，返回T
         */
        Supplier&lt;Integer&gt; supplier = () -&gt; 10;
        System.out.println(supplier.get());
    }
</code></pre>

<h3 id="其他lambad表达式">其他lambad表达式</h3>

<pre><code class="language-java">    public static void mapreducer() {
        System.out.println(Arrays.asList(1, 2, 3, 4, 5).stream().map(cost -&gt; 5 + cost)
            .reduce(10, (sum, cost) -&gt; sum + cost).toString());

        System.out
            .println(Arrays.asList(1).stream().reduce(10, (sum, cost) -&gt; sum + cost).toString());

    }

    public static void mapcollect() {
        System.out.println(Arrays.asList(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;chinese&quot;, &quot;person&quot;).stream()
            .map(cost -&gt; cost.toUpperCase()).collect(Collectors.joining(&quot;, &quot;)));
        System.out.println(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;0&quot;).stream()
            .map(cost -&gt; 5 + cost).collect(Collectors.counting()));

    }
</code></pre>

<h3 id="注意事项">注意事项</h3>

<ul>
<li>lambda是一个表达式而已，可以称为闭包或者匿名函数</li>
<li>当一个类使用了@Functional注释的函数式接口，自带抽象函数方法或者单个抽象方法时才可以使用lambda</li>
<li>当不改变lambda当中的变量值的时候才可以使用方法引用；list.forEach(System.out::println);</li>
</ul>

<pre><code class="language-java">list.forEach(System.out::println);
</code></pre>

<ul>
<li>在lambda当中的局部变量必须为final型的</li>
</ul>

</div>


    </div>

    
  </body>
</html>