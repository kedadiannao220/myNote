** 设计原则 
- 多用组合，少用继承
- 针对接口编程，不根据实现编程
- 变化的部分与不变的部分分离
- 为了交互对象之间的松耦合设计而努力
- 类应该是对扩展开放，对修改关闭
- 依赖倒置原则：要依赖抽象，不要依赖具体类
- 最小知识原则：只和你的密友谈话
- 好莱坞原则：别调用我们，我们会调用你

** 第一章 策略模式
- 使用模式这样的词汇可以让大家更快的知道你的设计思想
- 良好的oo设计具备：可复用，可扩充，可维护三个特性

*** 自己的总结
- 多用接口，少用继承
- 多用继承与接口的组合，可以在接口的实现当中封装不同的方法

** 第二章 观察者模式
*** 有味道的话
- 为了让程序的消息更加灵通，不错过该对象相关的事情
- 观察者模式：监听事件、订报等
- 让主题与观察者松耦合
- 主题与观察者是一对多的关系
- java内置observable对象
- observable里面的setChanged方法的意义在于，在何时我想修改，让观察的事情不是那么的灵敏

** 第三章 装饰者模式
*** 有味道的话
- 不修改底层的代码，为类添加新的方法和功能
- 装饰者和被装饰者拥有相同的超类型
- 可以使用一个或多个装饰者来包装同一个对象
- 因为装饰者和被装饰者有相同的超类型，所以需要修改超类型的地方可以通过装饰者来修改
- 对象可以在任何时候被装饰，可以在运行时，动态地，不限量地用装饰者装饰他。
- 在子类当中的构造方法必须将被装饰的对象传入
- 弊端：需要定义太多的子类
*** 装饰者模式需求
1. 杯子的大小
2. 可以打折
3. 可以变更每一种原料的价格
4. 可以有送礼物

** 第四章  工厂模式
1. 把静态方法定义为一个工厂的弊端不能使用继承
** 第五章 单例模式（Singleton）
1. 一个对象一旦被创建，其他人就不能再次创建
2. 全局变量也可以做到这点，但是如果在类创建的时候需要消耗大量的资源就不太合适
3. 单例模式用于注册表修改，内存池等资源的创建等
4. 单例模式没有公开的构造方法，是私有的，通过getInstance()方法可以得到实例
5. 保证其他线程不调用此类的方法是将getInstance()方法声明为同步的synchronized，但大量的同步会降低性能
6. 可以采用双重检查加锁的方法。用volatile关键字来修饰变量，一旦变更被实例化，其他的线程会接受初始化后的变量值
7. 单例的类不适合用于当作父类使用，它没有构造方法，需要将它的构造方法修改为public
** 第六章 命令模式
1. 命令模式是将请求封闭成对象，以便使用不同的请求；即请求对象与执行对象解耦。
2. 我的想法是用switch case去编码，但是这样一来，如果有新的入参类型出现，需要修改原码
3. 将入参封装为对象，当有新的入参类型出现的时候，将其转换为对象，然后直接调用即可
4. 实现思路：
   - 封装一个command接口，定义execute、undo等方法；
   - 定义Light类，实现on、off方法
   - 定义command的实现类LightOnCommandImpl，实现execute方法，让灯打开；unod方法，让灯关闭
   - 定义指令中心类commandController，根据入参来判断构造方法入参是否为Light，然后调用execute方法实现
5. 适用范围：线程池，队列调用，日志请求等

** 第七章 适配器模板及外观模式
*** 适配器模式
1. 接口转换为客户期望的另外一个接口，不需要修改原有的接口实现
2. 适配器分为对象适配器和类适配器；
   - 类适配器继承了原有接口及用户所需要的接口，而对象适配器只实现用户所需要的接口；
   - 类适配器不需要写原有对象，甚至可以改写原有对象的方法实现；对象适配器需要写很多的原有对象适配器
   - 类适配器需要继承用户所需接口，同时在构造方法当中引入原有接口
*** 外观模式：
1. 将部分子类用一个大类进行包装，可以完成这些子类的所有操作；不需要让用户关心底层的具体实现，但用户也可以直接调用子类进行实现
2. 每一个子类可以存在多个外观，可以让多个大类进行包装
3. 外观将客户从组件（子类）当中解耦，只需要修改外观即可
4. 外观的作用只是简化接口的调用
** 第八章 模板模式
1. 在一个方法中定义一个算法，使得子类在不改变算法的情况下，重新定义算法的步骤。
2. 可以在算法当中添加钩子，让用户可以进行不同的操作
3. 
