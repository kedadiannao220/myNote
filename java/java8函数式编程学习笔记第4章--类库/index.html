<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.20" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> &middot; My New Hugo Site</title>

  
  <link rel="stylesheet" href="http://kedadiannao220.github.io/css/print.css" media="print">
  <link rel="stylesheet" href="http://kedadiannao220.github.io/css/poole.css">
  <link rel="stylesheet" href="http://kedadiannao220.github.io/css/syntax.css">
  <link rel="stylesheet" href="http://kedadiannao220.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="My New Hugo Site" />
</head>

  <body class=" ">
  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://kedadiannao220.github.io/"><h1>My New Hugo Site</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="http://kedadiannao220.github.io/">Home</a> </li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1></h1>
  <span class="post-date">Mon, Jan 1, 0001</span>
  

<h2 id="第4章-类库">第4章 类库</h2>

<h3 id="数据类型">数据类型</h3>

<ul>
<li>int占用4字节，Integer占用16字节;Integer为整形对象</li>
<li>在最坏的情况下，Integer[]要比int[]多占用6倍的内存</li>
<li>所以拆箱效率比装箱快</li>
</ul>

<pre><code class="language-java">    public static void mapToFun() {
        System.out.println(Stream.of(new Integer(20)).mapToInt(x -&gt; x.intValue()).count());
        System.out.println(Stream.of(new Integer(20)).mapToLong(x -&gt; x.longValue()).count());
        System.out.println(Stream.of(new Integer(20)).mapToDouble(x -&gt; x.doubleValue()).count());
    }

    public static void intStream() {

        System.out.println(IntStream.of(1, 2, 3).average().getAsDouble());
        System.out.println(IntStream.of(1, 2, 3).max().getAsInt());
        System.out.println(IntStream.of(1, 2, 3).min().getAsInt());
        System.out.println(IntStream.of(1, 2, 3).findFirst().getAsInt());
        System.out.println(IntStream.of(1, 2, 3).findAny().getAsInt());
        System.out.println(IntStream.of(1, 2, 3).count());
        System.out.println(IntStream.of(1, 2, 3).sum());
        System.out.println(IntStream.of(1, 2, 3).limit(2).findFirst().getAsInt());
        IntStream.range(1, 10).forEach(x -&gt; System.out.println(x));

    }
</code></pre>

<h3 id="optional">Optional</h3>

<pre><code class="language-java">    public static void OptionalTest() {
        System.out.println(Optional.of(&quot;ab&quot;).get());
        //        System.out.println(Optional.of(null).get());//NPE
        System.out.println(Optional.ofNullable(null).orElse(&quot;bb&quot;));
        System.out.println(Optional.empty().orElse(&quot;bb&quot;));
        System.out.println(Optional.of(&quot;aa&quot;).orElse(&quot;bb&quot;));
    }
</code></pre>

<h3 id="重载解析">重载解析</h3>

<ul>
<li>用lambda做为参数传递的时候遵守以下原则</li>
<li>若只有一个可能的目标类型，由相应的函数接口的参数类型推导得出</li>
<li>若有多个可能的目标类型，由相应的函数接口参数类型推导得出</li>
<li>若有多个可能的目标类型且最具体的目标类型不明确的时候，需要人为进行指定lambda的参数类型</li>
</ul>

<h3 id="default">default</h3>

<pre><code class="language-java">
interface Parent {

    public default void welcome() {
        System.out.println(&quot;this is parent&quot;);
    }
}

class ParentImpl implements Parent {

}

</code></pre>

<ul>
<li>使用default定义的接口方法不需要子类必须实现</li>
<li>若ParentImpl override了welcome方法，则会走ParentImpl方法</li>
</ul>

<h3 id="多继承">多继承</h3>

<pre><code class="language-java">interface Person {
    public default void welcome() {
        System.out.println(&quot;this is person&quot;);
    }
}

interface Parent {

    public default void welcome() {
        System.out.println(&quot;this is parent&quot;);
    }
}

class MultiChild implements Person, Parent {

    @Override
    public void welcome() {
        System.out.println(&quot;this is MultiChild&quot;);
    }
}
</code></pre>

<pre><code class="language-java">class ChildImpl {
    public void welcome() {
        System.out.println(&quot;this is ChildImpl&quot;);
    }
}

interface Parent {

    public default void welcome() {
        System.out.println(&quot;this is parent&quot;);
    }
}

class OverrideChildImpl extends ChildImpl implements Parent {

}


      new OverrideChildImpl().welcome();//输出 this is ChildImpl


</code></pre>

<ul>
<li>MultiChild实现了Parent，Person都有welcome方法，则子类MultiChild必须指定自己的welcome</li>
<li>子类只能一个了父类，但是可以有多个接口实现</li>
<li>OverrideChildImpl继承的父类和实现的接口当中都有welcome方法，则优先会走父类的方法；类优于接口</li>
<li>若OverrideChildImpl当中override了welcome方法，那么就会走子类的方法</li>
</ul>

</div>


    </div>

    
  </body>
</html>