<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javas on My New Hugo Site</title>
    <link>http://kedadiannao220.hugo.io/java/</link>
    <description>Recent content in Javas on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://kedadiannao220.hugo.io/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01~2%E7%AB%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01~2%E7%AB%A0/</guid>
      <description>前言 为什么要阅读本书  如何编写简单、干净、易读的代码，尤其是对于集合的操作 如何简单地使用并行计算提高性能 如何准确地为问题建模 如果写出更简单的并发代码 如何测试和调试Lambda表达式  第1章 简介 ?什么是函数式编程  核心是：在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值  第2章 Lambda表达式 第一个Lambda表达式 new Button().addActionListener(e -&amp;gt; { System.out.println(&amp;quot;hello world&amp;quot;); });  重要函数接口 public static void functionInterface() { /** * Predicate&amp;lt;T&amp;gt; 入参T,返回boolean */ Predicate&amp;lt;Integer&amp;gt; persi = x -&amp;gt; x &amp;gt; 6; System.out.println(persi.test(10)); /** * BinaryOperator&amp;lt;T&amp;gt; 入参T,T，返回T */ BinaryOperator&amp;lt;Integer&amp;gt; binaryOperator = (x, y) -&amp;gt; x + y; System.out.println(binaryOperator.apply(10, 2)); /** * Consumer&amp;lt;T&amp;gt; 入参T，无返回void */ Consumer&amp;lt;Integer&amp;gt; consumer = (x) -&amp;gt; System.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC3%E7%AB%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC3%E7%AB%A0/</guid>
      <description>第3章 流 外部迭代与内部迭代 public static void innerLoop() { /** * 运算结果为：50005000共计耗时：3 * 运算结果为：50005000共计耗时：119 */ int sum = 0; Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt;= 10000; i++) { set.add(i); } long start = System.currentTimeMillis(); for (int i : set) { sum += i; } long end = System.currentTimeMillis() - start; System.out.println(&amp;quot;运算结果为：&amp;quot; + sum + &amp;quot;共计耗时：&amp;quot; + end); long _start = System.currentTimeMillis(); sum = set.stream().reduce((count, x) -&amp;gt; count + x).</description>
    </item>
    
    <item>
      <title></title>
      <link>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC4%E7%AB%A0--%E7%B1%BB%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC4%E7%AB%A0--%E7%B1%BB%E5%BA%93/</guid>
      <description>第4章 类库 数据类型  int占用4字节，Integer占用16字节;Integer为整形对象 在最坏的情况下，Integer[]要比int[]多占用6倍的内存 所以拆箱效率比装箱快  public static void mapToFun() { System.out.println(Stream.of(new Integer(20)).mapToInt(x -&amp;gt; x.intValue()).count()); System.out.println(Stream.of(new Integer(20)).mapToLong(x -&amp;gt; x.longValue()).count()); System.out.println(Stream.of(new Integer(20)).mapToDouble(x -&amp;gt; x.doubleValue()).count()); } public static void intStream() { System.out.println(IntStream.of(1, 2, 3).average().getAsDouble()); System.out.println(IntStream.of(1, 2, 3).max().getAsInt()); System.out.println(IntStream.of(1, 2, 3).min().getAsInt()); System.out.println(IntStream.of(1, 2, 3).findFirst().getAsInt()); System.out.println(IntStream.of(1, 2, 3).findAny().getAsInt()); System.out.println(IntStream.of(1, 2, 3).count()); System.out.println(IntStream.of(1, 2, 3).sum()); System.out.println(IntStream.of(1, 2, 3).limit(2).findFirst().getAsInt()); IntStream.range(1, 10).forEach(x -&amp;gt; System.out.println(x)); }  Optional public static void OptionalTest() { System.out.println(Optional.of(&amp;quot;ab&amp;quot;).get()); // System.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC5%E7%AB%A0--%E9%AB%98%E7%BA%A7%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://kedadiannao220.hugo.io/java/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC5%E7%AB%A0--%E9%AB%98%E7%BA%A7%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
      <description> 第5章 方法引用 </description>
    </item>
    
    <item>
      <title></title>
      <link>http://kedadiannao220.hugo.io/java/corejavai/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://kedadiannao220.hugo.io/java/corejavai/</guid>
      <description>Java核心技术&amp;ndash;卷I 第1章 Java程序设计概述 java发展史  1996年sun公司发布java 1.0版本 1998年在JavaOne大会上发布java 2.0版本 2004年在JavaOne会议上发布5.0版本 2006年年末发布6.0版本 2009年sun公司被收购 2011年oracle发布1.7版本 2013年oracle发布1.8版本  第2章 Java程序设计环境 第3章 Java的基本程序设计结构 数据类型 类型 存储需求 取值范围
int 4字节 &amp;gt;20亿 short 2字节
long 8字节
byte 1字节 -128~127 float 4字节
double 8字节
boolean false/true char unicode编码
 前缀0x:16进制 前缀0:8进制 前缀0b:二进制 数字字面量可以加下划线：1~000000表示1百万~  位运算  &amp;amp;  \^
 ~
 &amp;gt;&amp;gt;:右移
 &amp;lt;&amp;lt;:左移
  字符串 由于在虚拟机当中相同的字符串是共享的，理论上可以使用==来判断两个字符串的值是否相等；实际上只有字符串常量是共享的，而+或substring等操作产生的结果是不共享的
第4章 对象与类 面向对象程序设计（OOP-Object Oriented Programming） 对象的三个特性  对象的行为（behavior） 对象的状态(state) 对象标识(identity)  表达类关系之间有UML符号  继承 接口实现 依赖 聚合 关联 直接关联  第5章 继承  被final声明的类，不允许被继承，类中的方法也为final的，java当中的String就是final的；Calendar当中的setTime()和getTime()也是final的 被final声明的类可以在不使用动态绑定，节省系统的开销； 抽象类不能被实例化，只能实例化它的子类 hashCode()与equals()的返回值是相同的 方法当中的入参为 objedct&amp;hellip;这种形式叫做 参数可变  继承的设计技巧  将公共操作和属性放在父类当中 不要使用受保护的属性 使用继承实现&amp;rdquo;is-a&amp;rdquo;的关系 除非所有的继承方法都有意义，否则不要放到父类当中 覆写方法的时候，不要改变预期的行为 使用多态，而不是instanceOf的判断 不要过多使用反射  第6章 接口与内部类 接口  接口不是类，但是定义了对类的需求描述，类必须实现接口里面的方法定义 接口不是类，所以无法实例化 接口与抽象类的区别；java里面只支持单继承，接口则可以被多实现；  深度clone  由于每个的父类都是object，而object当中有clone的方法；所以每个类都可以使用clone方法；但结果就是浅clone；即无法拷贝类内部的对象 如果一个类想要重写clone方法，就必须实现Cloneable接口，同时定义public的clone方法，并实现clone方法  内部类  内部类的好处：访问控制和隐式调用 显式内部类：在实例化对象的时候将对象里面的方法进行实现  第11章 异常、断言、日志和调试  java异常都是继承于Throwable；分为error和exception;而exception又分为派生RuntimeException和其他异常 派生异常RuntimeException包括：错误类型转换、数组访问越界、空指针 非派生异常包括：试图在文件结尾处读取数据、试图打开一个不存在的文件、找不到类等 断言: assert 条件：表达式 断言的启用和禁用：java -ea或java -enableassertions xxx LOG日志记录7个级别：SERVER||WARNING||INFO||CONFIG||FINE||FINER|FINEST 使用ResourceBundle可以对日志进行本地化处理，但是需要在配置en~properties和zhproperties等不同语言的配置文件~ 11.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://kedadiannao220.hugo.io/java/corejavaii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://kedadiannao220.hugo.io/java/corejavaii/</guid>
      <description> Java核心技术卷二 第3章 网络编程 socket  socket(String host,String port):获取一个套接字 socket.getInputStream(): 获取流的数据信息 socket.setTimeout(1000): 设置socket连接超时时间 socket.isConnect(): socket.shutdownOutPut(): 半关闭，客户端向服务器端发送完数据之后就关闭套接字 socket.isInputShutdown()): 测试Input是否shutdown socket.isOutputShutdown()): 校验outPut是否shutdown  ServerSocket SocketChannel URL 第5章 国际化 第8章 JavaBean构件 第9章 安全 Java提供三种安全机制  语言设计特性（对数组边界进行检查，无不受检查的类型转换，无指针算法等） 访问控制机制，用于控制代码能够执行操作（文件访问，网络访问） 代码签名，作者可以使用标准的加密算法来认证java代码，准备知道代码被谁创建，被谁修改  类加载器 Java程序的三个类加载器  引导类加载器：通常从rt.jar当中进行加载，是虚拟机不可缺少的部分 扩展类加载器：项目或工程当中引入的jar包 系统类加载器：环境变量所配置的jre当中的类  </description>
    </item>
    
  </channel>
</rss>