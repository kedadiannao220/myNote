#+TITLE: 深入理解java虚拟机-jvm高级特性与最佳实践
#+DATE: 2017-05-21T23:13:33+08:00
#+PUBLISHDATE: 2017-05-21T23:13:33+08:00
#+DRAFT: nil
#+TAGS: Java, jvm
#+DESCRIPTION: Short description

* 第1部分 走近Java

** 第1章 走近java
   - JDK(java development kit)java开发工具，包括java程序设计语言，api类库，Java虚拟机
   - JRE(java runtime environment)：java se api和java虚拟机称为JRE
   - Java体系的四个平台
     - Java Card:支持小内存设备的应用：智能卡等
     - Java ME(java micro Edition):支持面向移动终端的应用：手机，平板等
     - Java SE(java Standard Edition):支持面向桌面级应用：windows应用
     - Java EE(java Enterprise Edition):支持多层架构的企业级应用：erp,crm

*** java虚拟机发展史
    - Sun Classic VM是世界上第一款商用Java虚拟机（1996年1月23）;后续被Exact VM取代；
    - Exact VM：准确式内存管理，拥有两级即时编译器、编译器与解释器混合工作模式等
    - HotSpot VM:是Sun JDK和OpenJDK中所带的虚拟机，目前使用范围最广，不是Sun公司开发的，而是Longview Technologies小公司设计，后被Sun收购；
      - HotSpot:热点代码探测技术
    - JRockit VM:由BEA公司研发，曾经号称“世界上速度最快的Java虚拟机”，JRockit的垃圾收集器和MissionControl服务套件等部分的实现处于领先水平
    - J9 VM: IBM研发的用于IBM产品和AIX、z/OS这些平台


* 第2部分 自动内存管理机制
** 第2章 Java内存区域与内存溢出异常
*** 2.1 概述
    C语言的内存管理是由开发者自行操作的，所以当开发者经验不足的时候就会写出内存溢出的代码；而java的内存则由虚拟机进行管理，开发人员不用担心内存回收和使用的问题；但是当内存溢出的时候，如果不懂得jvm是怎么操作内存的，排查问题就会比较麻烦

*** 2.2 运行时数据区域
    - 虚拟机栈
    - 本地方法栈
    - 方法区
    - 堆
    - 程序计数器

**** 2.2.1 程序计数器
    - 程序计数器是一块小的区域，每一个线程都有独立的程序计数器，保证线程在切换的时候可以恢复到正确的执行位置；字节码解释器就是通过改变程序计数器来执行for、while、swtich等表达式;

**** 2.2.2 java虚拟机栈
    - java虚拟机栈是线程私有的，生命周期与线程相同,每个方法在创建使用的时候都会创建一个栈帧，方法的调用对应着方法所对应的栈帧从入栈到出栈的过程
    - 虚拟机栈局部变量表存放着java的基础数据类型，对象引用和returnAddress类型，其中long和double占用了两个slot
    - 若线程请求的栈的深度大于虚拟机所允许的深度，抛StackOverflowError
    - 若线程请求的内存大小超出了可以申请的内存，抛OutOfMemoryError

**** 2.2.3 本地方法栈
     - 本地方法栈为线程找到本地的Native方法，虚拟机栈为线程使用java服务
     - 本地方法栈同虚拟机栈一样会抛出两个异常

**** 2.2.4 java堆（java Heap）
     - 堆是内存当中管理最大的一块，堆里面的内存供线程共享
     - 堆内存由虚拟机启动时创建，存放对象实例、数组
     - java堆可以处于物理上面内存不连续，扩展一般通过Xmx和Xms来控制

**** 2.2.5 方法区
     - 方法区的内存同堆内存一样，供线程共享
     - 存放着已经被虚拟机加载的类、常量、静态变量、即时编译后的代码数据
     - 当方法区无法满足线程所申请的内存时，抛出OOM异常

**** 2.2.6 运行时常量池（Runtime Constant Pool）
     - 用于存放类当中的常量信息
     - 常量池属于方法区的一部分

**** 2.2.7 直接内存（Direct Memory）
     - 直接内存不是运行时数据区域，也不是java虚拟机里面定义的内存，但是可以将一些数据信息放到直接内存当中，避免在堆内存和方法区当中来回复制，以提高效率
     - 若服务器物理内存不足时，会抛出OOM异常

*** 2.3 HotSpot虚拟机对象探秘

**** 2.3.1 对象创建
     - 对象创建的步骤是什么？虚拟机遇到new关键字，检查常量池当中是否存在类的引用，并检查此类是否加载，初始化等；若没有加载，则会走类加载的流程；若已经加载，则进入堆内存的分配；若堆内存是规整的，则使用指针碰撞的方式进行分配，若不规整，则根据虚拟机记录的空闲列表进行分配
     - 如何保证对象在多个线程创建的时候是不会重复的？对象在创建的时候，每个线程会在堆内存当中预先分配一小段内存叫做本地线程分配缓冲区（Thread Local Allocation Buffer TLAB）当TLAB分配完的时候才会进行同步创建堆内存的处理；另一种方式是直接同步进行创建

**** 2.3.2 对象内存布局
     - 对象在内存当中存储的部局有3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
     - 对象头里面包括两部分：第一部分用于存储对象自身的运行时数据，如hashCode，GC分代年龄，锁状态标志，线程持有的锁、偏向线程ID、偏向时间戳等，这些数据被称为Mark Word，长度为32bit或64bit；如果是数组还需要一块记录数据长度的区域；

| 存储内容                             | 标志位 | 状态               |
|--------------------------------------+--------+--------------------|
| 对象hashCode，对象分代年龄           |     01 | 未锁定             |
| 指向锁记录的指针                     |     00 | 轻量级锁定         |
| 指向重量级锁的指针                   |     10 | 膨胀（重量级锁定） |
| 空，不需要记录信息                   |     11 | GC标记             |
| 偏向线程ID，偏向时间戳，对象分代年龄 |     01 | 可偏向             |

     - HotSpot虚拟机默认分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops，相同宽度的字段总是被分配到一起
     - HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍

**** 2.3.3 
