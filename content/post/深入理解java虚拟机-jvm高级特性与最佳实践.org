#+TITLE: 深入理解java虚拟机-jvm高级特性与最佳实践
#+DATE: 2017-05-21T23:13:33+08:00
#+PUBLISHDATE: 2017-05-21T23:13:33+08:00
#+DRAFT: nil
#+TAGS: Java, jvm
#+DESCRIPTION: Short description

* 第1部分 走近Java

** 第1章 走近java
   - JDK(java development kit)java开发工具，包括java程序设计语言，api类库，Java虚拟机
   - JRE(java runtime environment)：java se api和java虚拟机称为JRE
   - Java体系的四个平台
     - Java Card:支持小内存设备的应用：智能卡等
     - Java ME(java micro Edition):支持面向移动终端的应用：手机，平板等
     - Java SE(java Standard Edition):支持面向桌面级应用：windows应用
     - Java EE(java Enterprise Edition):支持多层架构的企业级应用：erp,crm

*** java虚拟机发展史
    - Sun Classic VM是世界上第一款商用Java虚拟机（1996年1月23）;后续被Exact VM取代；
    - Exact VM：准确式内存管理，拥有两级即时编译器、编译器与解释器混合工作模式等
    - HotSpot VM:是Sun JDK和OpenJDK中所带的虚拟机，目前使用范围最广，不是Sun公司开发的，而是Longview Technologies小公司设计，后被Sun收购；
      - HotSpot:热点代码探测技术
    - JRockit VM:由BEA公司研发，曾经号称“世界上速度最快的Java虚拟机”，JRockit的垃圾收集器和MissionControl服务套件等部分的实现处于领先水平
    - J9 VM: IBM研发的用于IBM产品和AIX、z/OS这些平台

      
* 第2部分 自动内存管理机制
** 第2章 Java内存区域与内存溢出异常
*** 2.1 概述
    C语言的内存管理是由开发者自行操作的，所以当开发者经验不足的时候就会写出内存溢出的代码；而java的内存则由虚拟机进行管理，开发人员不用担心内存回收和使用的问题；但是当内存溢出的时候，如果不懂得jvm是怎么操作内存的，排查问题就会比较麻烦

*** 2.2 运行时数据区域
    - 虚拟机栈
    - 本地方法栈
    - 方法区
    - 堆
    - 程序计数器

**** 2.2.1 程序计数器
    - 程序计数器是一块小的区域，每一个线程都有独立的程序计数器，保证线程在切换的时候可以恢复到正确的执行位置；字节码解释器就是通过改变程序计数器来执行for、while、swtich等表达式;

**** 2.2.2 java虚拟机栈
    - java虚拟机栈是线程私有的，生命周期与线程相同,每个方法在创建使用的时候都会创建一个栈帧，方法的调用对应着方法所对应的栈帧从入栈到出栈的过程
    - 虚拟机栈局部变量表存放着java的基础数据类型，对象引用和returnAddress类型，其中long和double占用了两个slot
    - 若线程请求的栈的深度大于虚拟机所允许的深度，抛StackOverflowError
    - 若线程请求的内存大小超出了可以申请的内存，抛OutOfMemoryError

**** 2.2.3 本地方法栈
     - 本地方法栈为线程找到本地的Native方法，虚拟机栈为线程使用java服务
     - 本地方法栈同虚拟机栈一样会抛出两个异常

**** 2.2.4 java堆（java Heap）
     - 堆是内存当中管理最大的一块，堆里面的内存供线程共享
     - 堆内存由虚拟机启动时创建，存放对象实例、数组
     - java堆可以处于物理上面内存不连续，扩展一般通过Xmx和Xms来控制

**** 2.2.5 方法区
     - 方法区的内存同堆内存一样，供线程共享
     - 存放着已经被虚拟机加载的类、常量、静态变量、即时编译后的代码数据
     - 当方法区无法满足线程所申请的内存时，抛出OOM异常

**** 2.2.6 运行时常量池（Runtime Constant Pool）
     - 用于存放类当中的常量信息
     - 常量池属于方法区的一部分

**** 2.2.7 直接内存（Direct Memory）
     - 直接内存不是运行时数据区域，也不是java虚拟机里面定义的内存，但是可以将一些数据信息放到直接内存当中，避免在堆内存和方法区当中来回复制，以提高效率
     - 若服务器物理内存不足时，会抛出OOM异常

*** 2.3 HotSpot虚拟机对象探秘

**** 2.3.1 对象创建
     - 对象创建的步骤是什么？虚拟机遇到new关键字，检查常量池当中是否存在类的引用，并检查此类是否加载，初始化等；若没有加载，则会走类加载的流程；若已经加载，则进入堆内存的分配；若堆内存是规整的，则使用指针碰撞的方式进行分配，若不规整，则根据虚拟机记录的空闲列表进行分配
     - 如何保证对象在多个线程创建的时候是不会重复的？对象在创建的时候，每个线程会在堆内存当中预先分配一小段内存叫做本地线程分配缓冲区（Thread Local Allocation Buffer TLAB）当TLAB分配完的时候才会进行同步创建堆内存的处理；另一种方式是直接同步进行创建

**** 2.3.2 对象内存布局
     - 对象在内存当中存储的部局有3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）
     - 对象头里面包括两部分：第一部分用于存储对象自身的运行时数据，如hashCode，GC分代年龄，锁状态标志，线程持有的锁、偏向线程ID、偏向时间戳等，这些数据被称为Mark Word，长度为32bit或64bit；如果是数组还需要一块记录数据长度的区域；

| 存储内容                             | 标志位 | 状态               |
|--------------------------------------+--------+--------------------|
| 对象hashCode，对象分代年龄           |     01 | 未锁定             |
| 指向锁记录的指针                     |     00 | 轻量级锁定         |
| 指向重量级锁的指针                   |     10 | 膨胀（重量级锁定） |
| 空，不需要记录信息                   |     11 | GC标记             |
| 偏向线程ID，偏向时间戳，对象分代年龄 |     01 | 可偏向             |

     - HotSpot虚拟机默认分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops，相同宽度的字段总是被分配到一起
     - HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍

**** 2.3.3 对象的访问定位
     - 目前对象的访问方式主流的有两种，一种是使用句柄，另一种是直接指针
     - 句柄访问：reference数据存放于栈当中，但栈当中实际存储的是对象的句柄地址，句柄地址实际上是放在堆内存当中，它包含着对象实例数据与类型数据各自的地址信息；因为如果使用句柄进行访问，那么堆当中会划分出一块内存做为句柄池
     - 直接指针：如果为直接指针，那么栈当中的reference存放的就是实际的对象地址
     - 两者之间的区别：句柄访问的时候，如果对象的实际指针发生变化，只会修改句柄地址指向的指针信息，不会影响reference当中的地址，更加稳定；而使用直接指针的方式就是速度更快，因为不需要通过句柄地址去找对象实际的指针地址，节省再次定位实际对象指针的时间开销；

*** 2.4 实战OOM异常
    - 为什么说程序计数器不会发生OOM异常:此处基本没有内存开销，主要是操作一些语法表达式，对当前线程进行添加flag操作

**** 2.4.1 Java堆溢出
     - jvm启动内存参数指定：Xms:堆的最小值，Xmx:堆的最大值
     - 当发生OOM异常的时候，第一步需要根据内存映射分析工具（MAT）进行分析，首先判断是内存泄漏还是内存溢出；如果不是内存泄露，那么可以将jvm启动参数适当调大；
     - 如果是内存泄露，可以通过泄露工具进行查看GC Roots的引用链，找到为什么垃圾回收无法回收此泄露对象
    
**** 2.4.2 虚拟机栈和本地方法栈溢出 
     - HotSpot不区分虚拟机栈和本地方法栈，所以参数-Xoss是无效的，只有-Xss是有效的
#+BEGIN_SRC java
/**
 * Xss参数测试OOM异常与SOE异常
 *
 *  -Xss160k
 * Created by admin on 19/06/2017.
 */
public class XssOOM {
    static int i = 0;

    public static void count() {
        i++;
        count();
    }

    public static void main(String[] args) {

        System.out.println("Total Memroy: " + Runtime.getRuntime().totalMemory() / 1024 / 1024);
        System.out.println("Max Memory: " + Runtime.getRuntime().maxMemory() / 1024 / 1024);
        System.out.println("Free Memroy: " + Runtime.getRuntime().freeMemory() / 1024 / 1024);

        try {
            count();
        } catch (Throwable e) {
            /**
             * Total Memroy: 123
             * Max Memory: 1820
             * Free Memroy: 117
             * i值为:825,操作异常:java.lang.StackOverflowError
             */
            System.out.println("i值为:" + i + ",操作异常:" + e);
        }
    }
}

/**
 * Xss参数测试OOM异常
 * 
 * -Xss2M
 * Created by admin on 19/06/2017.
 */
public class XssOOM {

    public static void stopThread() {
        while (true) {

        }
    }

    public static void threadNew() {
        while (true) {
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    stopThread();
                }
            });
            thread.start();
        }
    }

    public static void main(String[] args) {
        System.out.println("Total Memroy: " + Runtime.getRuntime().totalMemory() / 1024 / 1024);
        System.out.println("Max Memory: " + Runtime.getRuntime().maxMemory() / 1024 / 1024);
        System.out.println("Free Memroy: " + Runtime.getRuntime().freeMemory() / 1024 / 1024);

        XssOOM xssOOM = new XssOOM();
        xssOOM.threadNew();

    }
}
#+END_SRC

**** 2.4.3 方法区和运行时常量池的溢出
     - 异常信息为：java.lang.OutOfMemoryError: PermGen space
     - 通过XX参数来进行控制 -XX:PermSize=10M -XX:MaxPermSize=10M
     - 运行时常量池属于内存当中的永久代

**** 2.4.4 本地内存溢出
     - 异常信息为：java.lang.OutOfMemoryError: PermGen space
     - 通过 -XX:MaxDirectMemorySize=2M 来指定直接内存大小的最大值，若不设定，则指与-Xmx的值一样
 

** 第3章 垃圾收集器与内存分配策略
*** 3.1 概述
    - Lisp语言是最早使用内存分配并GC的语言
    - 因为垃圾收集成为了高并发的瓶颈，并且需要排查内存溢出等复杂问题
    - 程序计数器、虚拟机栈、本地方法三个区域是随着线程生而生，线程灭而灭，所以内存的GC是固定的；我们只关心运行时的内存GC，因为只有在运行时我们才知道需要创建什么对象

*** 3.2 对象已死么
    - java堆当中存放着几乎所有的java对象实例，在GC的时候，需要去判断这些对象实例是否已经死亡
**** 3.2.1 引用计数算法
    - 对象引用的时候，计数器+1，引用失效的时候，计数器-1；但这种算法无法处理对象互相引用的问题
    - 如果两个对象互相引用 ，计数器都不为0，此时GC就不会回收他们
    - 所以在java没有彩计数器的算法来GC

**** 3.2.2 可达性分析算法
     - 通过一个对象的GC来做为Root，向下搜索看看是否存在引用的链路，若存在，说明是对象实例是活着的，无法GC，若不存在，则GC
     - 几个对象互相引用，但如果没有实例化，则会被GC掉
     - java当中可以做为GC ROOT的对象有以下几种 ：虚拟机栈当中的对象；方法区表类静态属性引用的对象；方法区当中常量引用的对象；本地方法栈中JNI引用的对象

**** 3.2.3 再谈引用
     - 有一些缓存数据，是没有引用关系的，那么这些如果被GC掉就会非常的可惜，所以java当中将引用分为几个等级；
     - 强引用（Strong Reference） ：new 出来的对象，这类对象只要引用存在，则不会被回收掉
     - 软引用（Soft Reference）：只有当内存发生溢出的时候才会把这些对象回收掉
     - 弱引用（Weak Reference）：只要GC工作的时候，就一定会被回收，存活于两次GC的间隔
     - 虚引用（Phanton Reference）：存在的目的就是在对象实例被回收的时候发出一个通知，无法实例化对象，属于最弱的引用 

**** 3.2.4 生存还是死亡
     - 一个对象若没有通过GC ROOT来找到对象的引用链，那么此时会被标记并筛选，若对象覆写finalize()方法或finalize()方法已经被虚拟机调用过（只能调用一次，第二次仍然会被GC掉），那么此对象不会被回收
     - 若没有需要执行finalize()方法，那么虚拟机将其放入F-Queue队列当中进行即将回收处理
     - 在即将回收处理的时候，对象可以通过finalize()方法当中通过重新建立引用来拯救自己

**** 3.2.5 回收方法区
     - 方法区当中的内存被称为永久代，永久代当中的内存回收效率很低，因为大家都比较“永久”，所以无法全部回收
     - 废弃的常量的回收：常量存在于常量池当中，当没有一个对象引用此常量的时候，将在GC的时候清理出常量池
     - 无用类的回收：当一个类当中的所有实例都被GC；无法通过反射生成类对象的实例；该类的ClassLoader已经被回收的时候,GC会将这些无用的类回收掉
     - 在操作大量反射的时候，需要注意内存的使用情况，以保证永久代不会溢出

*** 3.3 垃圾收集算法
**** 3.3.1 标记-清除算法
     - 它是最基础的垃圾收集算法
     - 它的不足在于被标记清除的内存会产生大量的碎片，而当内存需要分配大对象的时候，会导致内存不连续而无法分配，需要再次触发垃圾回收机制，所以效率不高

**** TODO 3.3.2 复制算法
     - 它的不足：对象过多的时候复制的效率就会下降

**** 3.3.3 标记-整理算法
     - 先进行标记清除算法，然后将存活的对象都向内存的一端移动，以保存内存空间可以连续，不产生碎片

**** 3.3.4 分代收集算法
     - 按照对象的存活周期进行分配，将java堆内存分为新生代和老年代两块；
     - 新生代里面对象经过GC以后存活的很少，采用复制算法进行回收
     - 老年代里面对象经过GC以后存活的很多，彩标记-整理算法进行回收

*** 3.4 HotSpot算法实现

