#+TITLE: 《深入理解java虚拟机-jvm高级特性与最佳实践》读书笔记 第3章 - 垃圾收集器与内存分配策略
#+DATE: 2017-06-28T22:31:40+08:00
#+PUBLISHDATE: 2017-06-28T22:31:40+08:00
#+DRAFT: nil
#+SHOWTOC: t
#+TAGS: Java, jvm
#+DESCRIPTION: Short description

** 第3章 垃圾收集器与内存分配策略
*** 3.1 概述
    - Lisp语言是最早使用内存分配并GC的语言
    - 因为垃圾收集成为了高并发的瓶颈，并且需要排查内存溢出等复杂问题
    - 程序计数器、虚拟机栈、本地方法三个区域是随着线程生而生，线程灭而灭，所以内存的GC是固定的；我们只关心运行时的内存GC，因为只有在运行时我们才知道需要创建什么对象

*** 3.2 对象已死么
    - java堆当中存放着几乎所有的java对象实例，在GC的时候，需要去判断这些对象实例是否已经死亡
**** 3.2.1 引用计数算法
    - 对象引用的时候，计数器+1，引用失效的时候，计数器-1；但这种算法无法处理对象互相引用的问题
    - 如果两个对象互相引用 ，计数器都不为0，此时GC就不会回收他们
    - 所以在java没有彩计数器的算法来GC

**** 3.2.2 可达性分析算法
     - 通过一个对象的GC来做为Root，向下搜索看看是否存在引用的链路，若存在，说明是对象实例是活着的，无法GC，若不存在，则GC
     - 几个对象互相引用，但如果没有实例化，则会被GC掉
     - java当中可以做为GC ROOT的对象有以下几种 ：虚拟机栈当中的对象；方法区表类静态属性引用的对象；方法区当中常量引用的对象；本地方法栈中JNI引用的对象
     - 弊端：当应用工程比较大的时候，在几百兆的内存当中去查询引用链是非常花费时间的；并且不能保证在查找的过程当中，引用链路会发生变化 

**** 3.2.3 再谈引用
     - 有一些缓存数据，是没有引用关系的，那么这些如果被GC掉就会非常的可惜，所以java当中将引用分为几个等级；
     - 强引用（Strong Reference） ：new 出来的对象，这类对象只要引用存在，则不会被回收掉
     - 软引用（Soft Reference）：只有当内存发生溢出的时候才会把这些对象回收掉
     - 弱引用（Weak Reference）：只要GC工作的时候，就一定会被回收，存活于两次GC的间隔
     - 虚引用（Phanton Reference）：存在的目的就是在对象实例被回收的时候发出一个通知，无法实例化对象，属于最弱的引用 

**** 3.2.4 生存还是死亡
     - 一个对象若没有通过GC ROOT来找到对象的引用链，那么此时会被标记并筛选，若对象覆写finalize()方法或finalize()方法已经被虚拟机调用过（只能调用一次，第二次仍然会被GC掉），那么此对象不会被回收
     - 若没有需要执行finalize()方法，那么虚拟机将其放入F-Queue队列当中进行即将回收处理
     - 在即将回收处理的时候，对象可以通过finalize()方法当中通过重新建立引用来拯救自己

**** 3.2.5 回收方法区
     - 方法区当中的内存被称为永久代，永久代当中的内存回收效率很低，因为大家都比较“永久”，所以无法全部回收
     - 废弃的常量的回收：常量存在于常量池当中，当没有一个对象引用此常量的时候，将在GC的时候清理出常量池
     - 无用类的回收：当一个类当中的所有实例都被GC；无法通过反射生成类对象的实例；该类的ClassLoader已经被回收的时候,GC会将这些无用的类回收掉
     - 在操作大量反射的时候，需要注意内存的使用情况，以保证永久代不会溢出

*** 3.3 垃圾收集算法
**** 3.3.1 标记-清除算法
     - 它是最基础的垃圾收集算法
     - 它的不足在于被标记清除的内存会产生大量的碎片，而当内存需要分配大对象的时候，会导致内存不连续而无法分配，需要再次触发垃圾回收机制，所以效率不高

**** TODO 3.3.2 复制算法
     - 它的不足：对象过多的时候复制的效率就会下降

**** 3.3.3 标记-整理算法
     - 先进行标记清除算法，然后将存活的对象都向内存的一端移动，以保存内存空间可以连续，不产生碎片

**** 3.3.4 分代收集算法
     - 按照对象的存活周期进行分配，将java堆内存分为新生代和老年代两块；
     - 新生代里面对象经过GC以后存活的很少，采用复制算法进行回收
     - 老年代里面对象经过GC以后存活的很多，彩标记-整理算法进行回收

*** 3.4 HotSpot算法实现
**** 3.4.1  枚举根节点
     - 可达性分析的弊端：工程比较大的时候，查找引用链比较费时；不能保证在查找过程当中引用链不发生变化
     - 目前主流的虚拟机都采用准确式GC，当系统停顿下来之后，可以快速计算出对象之间的引用
     - HotSpot通过OopMap的数据结构来记录，当类加载器加载完成后，将对象内什么偏移量是什么数据类型记录下来，同时在特定位置记录在栈和寄存器当中哪些位置是引用的；在GC的时候可以直接获取这些信息

**** 3.4.2 安全点
     - 但是每次引用链发生变化，都需要生成OopMap数据结构，导致需要大量的额外空间，怎么解决这样的问题呢？
     - 通过设定Safepoint，当程序到达安全点的时候，程序会停顿下来进行GC处理，才会生成OopMap数据结构，防止OopMap数据结构频繁地变化
     - Safepoint的值设置多大合适呢？长时间执行的程序才会产生Safepoint，像循环跳转，方法调用，异常跳转等；
     - 另外一个问题，如何保证程序在停顿的时候，所有的线程都停止？一种方式是抢先式中断，将所有的线程都中断，若发现某线程没有到到Safepoint，再进行恢复，但是基本没有虚拟机采用此种方式；另一种方法，设置标志在安全点的位置，线程在执行过程当中轮询此标志，若为true,则自动中断挂起

**** 3.4.3 安全区域
     - 当线程处于Sleep或者Blocked状态的时候，无法进入安全点，那么就不会被GC，此时就需要使用安全区域来解决这样的问题
     - 安全区域是指一段代码在一段时间里面，引用关系没有发生变化，那么在这个区域里面的任何地方开始GC都是安全的;
     - 虚拟机开始GC的时候，不会处理被标记为Safe Region的线程，当线程要离开Safe Region时，如果已经完成了GC，那么线程继续捃地，否则一直等待到可以安全离开为止
